const path = require('node:path');
const yaml = require('js-yaml');
const htmlMinifier = require('html-minifier-terser');
const sass = require('sass');
const postcss = require('postcss');
const postcssMediaMinmax = require('postcss-media-minmax');
const autoprefixer = require('autoprefixer');
const postcssCsso = require('postcss-csso');

module.exports = config => {
	config.ignores.add('src/components');

	config.addDataExtension('yml', content => yaml.load(content));

	// HTML
	config.addTransform('html-minify', (content, path) => {
		if (path && path.endsWith('.html')) {
			return htmlMinifier.minify(
				content, {
					collapseBooleanAttributes: true,
					collapseWhitespace: true,
					decodeEntities: true,
					includeAutoGeneratedTags: false,
					removeComments: true,
					sortAttributes: true,
					sortClassName: true
				}
			);
		}

		return content;
	});

	// STYLES
	config.addTemplateFormats('scss');
	config.addExtension('scss', {
		outputFileExtension: 'css',

		compile: async function(inputContent, inputPath) {
			const parsed = path.parse(inputPath);

			if(parsed.name.startsWith('_')) {
				return;
			}

			let result = sass.compileString(inputContent, {
				loadPaths: [
					parsed.dir || '.',
					'node_modules'
				]
			});

			this.addDependencies(inputPath, result.loadedUrls);

			return async () => {
				const output = await postcss([
					postcssMediaMinmax,
					autoprefixer,
					postcssCsso,
				]).process(result.css, { from: inputPath })
				return output.css;
			};
		}
	});


	// Passthrough copy
	[
		'src/assets/images',
		'src/assets/fonts',
	].forEach(
		path => config.addPassthroughCopy(path)
	);

	// Dev Server
	config.setServerOptions({
		watch: ['src/assets/**/*.scss']
	});

	// Config
	return {
		dir: {
			input: 'src',
			includes: 'includes',
			layouts: 'templates',
			data: 'data',
			output: 'build'
		}
	};
}